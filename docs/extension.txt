Writing a Silva Extension
=========================


This document descibes how to build a Silva product using a simple
blogging application as an example. You can check out the code of this
example in the `Infrae SVN <https://svn.infrae.com/silva.app.blog/trunk>`_.

Before doing so lets define the meaning of some terms used throughout this documentation.
A Silva product is a Silva extension, however extensions aren't necessarily products. In
this documentation the word extension is interchangeble with the word a product.

The word product is used both by Silva and Zope. Again a Silva product is a Zope product,
but a Zope product doesn't have to be a Silva product.

.. contents:: Table of Contents

Introduction
------------

You have two different ways to create a Silva extension:

1. As a standard Zope product,

2. As an egg.

After creating your extension there are two ways to declare it, and
its objects in Silva:

1. ZCML (Zope Configuration Markup Language),

2. Grok. Grok is sort of scanner which looks at your code and
   magically registers what is needed. If you want to use Grok, we
   recommend to use only Grok, and do not try to mix Grok with ZCML
   declaration.

To help us understand the different ways to implement ZCML and Grok we'll develop our blogging 
application using both ways.

About ZCML
~~~~~~~~~~

ZCML is a XML file format called ``configure.zcml`` by default. This
file uses namespaced tags to be able to handle different registration
actions used by the Silva extension. In this documentation, we be
making a ``configure.zcml`` file for the blog product.

Creating the Silva Blog product
-------------------------------

As a Zope product
~~~~~~~~~~~~~~~~~

In order to make a Silva extension it needs to be a Zope product. A
Zope product consists of the following:

- The product is a directory (with optional sub-directories and
  files).

- The product has a file called ``__init__.py`` in the root
  directory. This file can be empty, but the advice is to put at least
  a Python comment line in it (``#``), as some systems do not like
  completely empty files.

- The product directory is installed in a place that Zope looks for
  products, such as the Zope instance's ``Products`` directory. If you
  are using buildout this would be the ``products`` directory in your
  buildout instance of Zope.

- The name of your product directory must be the same as your product.

Basically, a Zope product is a Python package. Calling the product as
a python module with ``from`` or ``import`` looks like this:
``Products.product_directory``. This is true even if your product is
not located in a directory called ``Products``. This of course does
not follow the requirements just listed for a Zope product. The truth
of the matter is, where Zope looks for products can have any name, as
long as it is registered to contain products. For the sake of Silva
and Silva built using buildout all products should be located either
in the ``Products`` directory of the Zope instance, or the
``products`` directory of a buildout Zope instance.

As an `Egg`
~~~~~~~~~~~

`Eggs` are an way to provide and ship Python extension in a automated
way. The best way to use `eggs`, is to use them with the help of
`buildout <https://svn.infrae.com/buildout/silva/INSTALL.txt>`_.

You can create the structure of your `egg` with the help of the
`paster` command, and `ZopeSkel <http://pypi.python.org/pypi/ZopeSkel>`_:

.. sourcecode:: sh

  $ cd src
  $ paster create -t nested_namespace
  Selected and implied templates:
    ZopeSkel#nested_namespace  A project with two nested namespaces.

  Enter project name: silva.app.blog
  Variables:
    egg:      silva.app.blog
    package:  silvaappblog
    project:  silva.app.blog
  Enter namespace_package (Namespace package (like plone)) ['plone']: silva
  Enter namespace_package2 (Nested namespace package (like app)) ['app']: app
  Enter package (The package contained namespace package (like example)) ['example']: blog
  Enter version (Version) ['1.0']: 
  Enter description (One-line description of the package) ['']: My Extension
  Enter long_description (Multi-line description (in reST)) ['']: Long description about my extension.
  Enter author (Author name) ['']: Sylvain Viollon
  Enter author_email (Author email) ['']: info@infrae.com
  Enter keywords (Space-separated keywords/tags) ['']: silva app extension
  Enter url (URL of homepage) ['']: 
  Enter license_name (License name) ['GPL']: ZPL 2.1
  Enter zip_safe (True/False: if the package can be distributed as a .zip file) [False]: 
  Creating template nested_namespace
  Creating directory ./silva.app.blog
    Recursing into +namespace_package+
      Creating ./silva.app.blog/silva/
      Recursing into +namespace_package2+
        Creating ./silva.app.blog/silva/app/
        Recursing into +package+
          Creating ./silva.app.blog/silva/app/blog/
          Copying __init__.py_tmpl to ./silva.app.blog/silva/app/blog/__init__.py
        Copying __init__.py_tmpl to ./silva.app.blog/silva/app/__init__.py
      Copying __init__.py_tmpl to ./silva.app.blog/silva/__init__.py
    Copying README.txt_tmpl to ./silva.app.blog/README.txt
    Recursing into docs
      Creating ./silva.app.blog/docs/
      Copying HISTORY.txt_tmpl to ./silva.app.blog/docs/HISTORY.txt
    Copying setup.cfg to ./silva.app.blog/setup.cfg
    Copying setup.py_tmpl to ./silva.app.blog/setup.py
  Running /usr/local/bin/python2.4 setup.py egg_info

Here the Silva Blog product will reside in the newly created directory
``silva.app.blog/silva/app/blog``, which is a Python
module, accessible via ``silva.app.blog`` in your Python
code. It will be as well the name of your product in Zope (there is no
``Products``).

You need to create a file called ``configure.zcml`` in this directory,
to declare it as a Zope product. This is an XML file and should
contains:

.. sourcecode:: xml

  <configure
      xmlns="http://namespaces.zope.org/zope"
      xmlns:five="http://namespaces.zope.org/five">

    <five:registerPackage package="." />
  </configure>

After, if you use buildout, you can update your ``buildout.cfg`` file:

.. sourcecode:: ini

  [buildout]
  # Tells buildout that this egg exists.
  develop +=
     src/silva.app.blog

  [instance]
  # Add your egg to your Zope instance.
  eggs +=
     silva.app.blog
  # Load the ZCML for this egg. 
  zcml +=
     silva.app.blog

Add re-run ``buildout``:

.. sourcecode:: sh

  $ cd ..                            # Come back to the root directory of your buildout tree
  $ ./bin/buildout

This will let you use your egg while you will develop it, otherwise
you will have to install it each time you want to test your code using
the command ``easy_install``.

Notes
`````

- Here used the `nested_namespace` template to create our egg.  If you
  plan to create something called `silva.extension` (there is no
  `app`), you can use the `basic_namespace` template of `paster`.

- Because of the use of specific Zope python package, only present in
  a Zope environment, you may not be able to use your egg outside
  Zope. That's means as well you can't create an egg called
  `silva.mytech`, and `silva.mytech.extension`, if the first use some
  specific Zope package, otherwise operation on this egg (building,
  uploading) may fails due to missing import (these operations are not
  done by Zope or in a Zope environment).


From now, you should be able to restart your Zope instance, in ZMI, go
on `Control_Panel`, them `Products Management` and you will see your
extension in the listing.

Installation into the Silva Root
--------------------------------

You need to have an installer which is going to install our extension
in the selected Silva root. An installer is a class which define the
following methods:

``install``

   Is used to install the extension.

``uninstall``

   Is used to uninstall the extension.

``is_installed`` 

   Return ``True`` if the extension is installed, ``False`` otherwise.

Then you have this class, you create a instance called ``install`` in
the ``__init__.py`` file of your extension.

A default installer can be used, and extended. It provides the
following installation steps:

1. Add addable contents (all Silva content, no version content) to the
   addable list of the Silva site.

2. Register contents to the metadata service, to be able to set them
   on our objects. All contents are registered, but for versioned
   contents, class representing versions are registered instead of the
   class representing the content itself.

3. Eventually if you have one, register the ``views`` directory of
   your extension to the ``service_views``.

You don't need more steps to build an extension which create/add new
content in Silva.

As well, this installer use a marker interface on the
``service_extensions`` to known if the extension is installed.

So you can add to the ``__init__.py`` of our extension:

.. sourcecode:: python

  from silva.core.conf.installer import DefaultInstaller
  from zope.interface import Interface

  class BlogInstaller(DefaultInstaller):
      """Installer for the blog extension. Override install, uninstall 
      to add more actions.
      """


  class IBlogExtension(Interface):
      """Marker interface for our extension.
      """

  install = BlogInstaller("SilvaBlog", IBlogExtension)


The first argument to the installer is the name of our extension, the
second is the marker interface.

.. note::

  Your installer can be as well a module ``install.py`` in your
  extension, which defines the ``install``, ``uninstall`` and
  ``is_installed`` functions.


Registration with Grok
~~~~~~~~~~~~~~~~~~~~~~

Enabling Grok for your extension
````````````````````````````````

If you want to use Grok, you need to enable it in your extension.
This can be done with the help of a ZCML directive in the
``configure.zcml`` file located in your extension directory:

.. sourcecode:: xml

  <configure
    xmlns="http://namespaces.zope.org/zope"
    xmlns:grok="http://namespaces.zope.org/grok">

    <grok:grok package="." />

  </configure>

That's the last piece of required ZCML.


Registration
````````````

In the ``__init__.py`` of your extension, you can use the following
Python code to register it to Silva:

.. sourcecode:: python

  from silva.core import conf as silvaconf

  silvaconf.extensionName("SilvaBlog")
  silvaconf.extensionTitle("Silva Blog")

The name will be used internally, and the title will displayed in
``service_extension``. If your extension depends on another extension,
like `Silva Document` add an ``extensionDepends`` directive to your
the file:

.. sourcecode:: python

  silvaconf.extensionDepends("SilvaDocument")


If your extension has multiple dependencies, ``extensionDepends``
allows you to specify a tuple of strings.



Registration with ZCML
~~~~~~~~~~~~~~~~~~~~~~

In your extension directory, add the following ZCML directives to the
``configure.zcml``, or create the file if it doesn't exists yet:

.. sourcecode:: xml

  <configure
    xmlns="http://namespaces.zope.org/zope"
    xmlns:silva="http://infrae.com/ns/silvaconf">

    <silva:extension
      name="SilvaBlog"
      title="Silva Blog"
      />

  </configure>

You use the special ``silva:extension`` directive to specify the
extension name. You also give an extension title, which is a brief
description describing what the extension is about.


Reset point
~~~~~~~~~~~

At this point, you should be able to restart your Zope instance, and
be able to view, install and uninstall your extension using
`service_extensions` in the Silva root.

Creating content objects
------------------------

To illustrate that, lets create a module called `article.py` in your
product. This module will contain a new content object for Silva:

.. sourcecode:: python

  from Products.Silva.VersionedContent import CatalogedVersionedContent
  from Products.Silva.Version import CatalogedVersion

  class Article(CatalogedVersionedContent):
      meta_type = 'Silva Blog Article'

  class ArticleVersion(CatalogedVersion):
      meta_type = 'Silva Blog Article Version'

We assume here that you want to create a versioned content object.
Versioned content types consist of a versioned object (``Article`` in
this example) and associated version objects (``ArticleVersion``). The
``meta_type`` is a class attribute identifying a content type in Zope
2, and should be unique for each content type.

We are going to create a second module ``blog.py`` which is going to
contain a non-versioned folderish type:

.. sourcecode:: python

  from Products.Silva.Publication import Publication

  class Blog(Publication):
      meta_type = 'Silva Blog'


Available bases classes
~~~~~~~~~~~~~~~~~~~~~~~

All these class are located in Silva, ``Products.Silva`` python package.

``Asset.Asset``

  Basic asset, like file (``File.File``) or image (``Image.Image``).

``Folder.Folder``

  Basic folderish item. A Publication (``Publication.Publication``) is
  a subclass of it, and is recommended for main application container.

``VersionedContent.VersionedContent``

  A basic versioned content. You have to create a version object
  inheriting of ``Version.Version``.

``VersionedContent.CatalogedVersionedContent``

  Extension of the basic versioned content to support catalog. The
  version object should inherit of ``Version.CatalogedVersion``.




Use Grok to register your content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Regular content
```````````````

If your content inherit from ``Asset`` or ``Folder``, that's done. All
content in Silva does, so you just have to inherit from one Silva
content to make yours.

You can add some directive in your Python code:

.. sourcecode:: python

   from Products.Silva.Publication import Publication

   class Blog(Publication):
       meta_type = 'Silva Blog'
       silvaconf.icon(blog.png')           # Set an icon for the content
       silvaconf.factory('manage_addBlog') # Add a Zope factory for your content
       silvaconf.priority(-3)              # Set priority in addable menu

   def manage_addBlog(context, id, title):
       # Regular Zope manage_add function.

You can give more than one factory, and if the first one is a adding
form (the name should finish by ``Form``), it will be used to create
the content in ZMI using the adding menu.

If you don't provide a factory, a default one will be created for
you. It will create your content giving `id` to the constructor, and
set `title` on it using the Silva method ``set_title``.

Versioned content
`````````````````

This work like a regular content, your content have to inherit of
VersionedContent. You have to specify in this last one which class
should be used as version of your content:

.. sourcecode:: python

   from Products.Silva.VersionedContent import VersionedContent
   from Products.Silva.Version import Version

   class ArticleVersion(Version):
      ...

   class Article(VersionedContent):
      ...                                  # Other registration directives
      silvaconf.versionClass(ArticleVersion)


Like for regular content, you can as well provide a factory for your
version content, *in* ``Article``:

.. sourcecode:: python


      silvaconf.versionFactory('manage_addArticleVersion')


Use ZCML to register your content
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Regular content
```````````````

In your ``configure.zcml`` add this to register your content type:

.. sourcecode:: xml

  <silva:content
    extension_name="SilvaBlog"
    content=".blog.Blog"
    icon="blog.png"
    />

The `icon` attribute may be left out.

Versioned content
`````````````````

In your ``configure.zcml`` add this to register your versioned content
type:

.. sourcecode:: xml

  <silva:versionedcontent
    extension_name="SilvaBlog"
    content=".article.Article"
    version=".article.ArticleVersion"
    icon="article.png"
    />

Again, `icon` is optional.

Notes
`````

There are attributes of these zcml directives that aren't covered in
this document.  To learn more, read the definitions in
``silva.core.zcml.directives``.

       
Advanced topics with Grok
-------------------------

If you use Grok, you will be able to create easily new features in
your extension, without any special registration.


Public views
~~~~~~~~~~~~

You can provide Grok views on your content as public views. For
instance, if we take back the example of the blog, in the ``blog.py``
file we can create a public view:

.. sourcecode:: python
  :linenos:

  from Products.Silva.Publication import Publication
  from silva.core import conf as silvaconf
  from silva.core.conf import views as silvaviews

  class Blog(Publication):
       ...

  class BlogPublicView(silvaviews.View):

       silvaconf.context(Blog)

       def title(self):
            return self.content.get_title()



The class ``BlogPublicView`` represent the view.  It inherit from
``silva.core.conf.View`` *(line 8)*. The configuration directive
``silvaconf.context`` tells the view for which class it is working
*(line 10)*. You can specify an interface by your content as well
(like *IBlog*).

After you have to create a template associated to that view:

1. Create a directory called ``blog_templates``. It's the name of the
   Python module where the view code is, at which you append
   ``templates``,

2. In this directory, you can add a file called
   ``silvablogpublicview.pt``, it will be your template. This template
   will be linked to your view class, since it's the same name in
   lower case. This file can contains for example:

   .. sourcecode:: xml

        <div> My Blog <tal:replace tal:replace="view/title" /></div>


   In your template, ``context`` is mapped to the object on which you
   apply the view, and ``view`` to your view class. You can define
   some helpers for your template as methods on your view class.

Namespace
`````````

In page templates, you have the following variables available:

``context``

   Refer to the content object on which the rendering is done.

``content``

   Refer to the content object which should rendered. It can be
   different than context: if you have a versioned content object it
   will the viewable version of your object (for regular views), or
   the previewable version of your object (for preview).

``view``

   Refer to your view class you defined. You can add method helper on
   your class, and use them in your templates:

   .. sourcecode:: xml
  
     <tal:repeat tal:repeat="article view/fetch_articles">
         <a href="#"
            tal:attributes="href article/url"
            tal:content="article/title"> Title </a>
     </tal:repeat>


``template``

   Refer to your templates, where you should be able to use
   ``templates/marcos/mymacro`` if you define a macro called
   ``mymacro`` in your template.

Notes
`````

- If you don't want to use a template with your view class, you just
  have to define a ``render`` method:

  .. sourcecode:: python
    :linenos:

    class BlogPublicView(silvaviews.View):

         silvaconf.context(Blog)

         def render(self):
             return '<div> Hello %s !</div>' % self.content.get_value()


  The ``content`` attribute on the class *(line 6)* refer to the
  object to render, like the ``content`` variable available in page
  templates.

- You can execute code in the ``update`` method before the rendering
  of your template (or before the method ``render`` is called). 

- You can use the configuration directive ``silvaconf.templatedir`` in
  your module if you want to put your templates in a different
  directory than ``name-of-your-python-module_templates``.

- You can use the configuration directive ``silvaconf.name`` to
  provide a name to your view, so it won't be the default one. For
  instance, your can define a new template for RSS on the blog like
  that:


  .. sourcecode:: python

    class RSSBlogView(BlogPublicView):

         silvaconf.name('rss.xml')

  And after you create the template ``rsssilvablogview.pt`` in the
  ``blog_templates`` directory containing the corresponding code to
  render a RSS view on the content. Since your view inherit of
  ``BlogPublicView``, it will be automatically a view for ``Blog``
  objects, and have all the helpers you defined before.


XSLT Renderer
~~~~~~~~~~~~~

You can create a new XSLT renderer above your public view that way:

.. sourcecode:: python

  from Products.Silva.transform.renderer.xsltrendererbase import XSLTRendererBase
  from silva.core import conf as silvaconf

  class XSLTBlogRenderer(XSLTRendererBase):

      silvaconf.context(Blog)
      silvaconf.title('XSLT Renderer over blogs')
      silvaconf.XSLT(myrules.xslt')


Your XSLT file is searched from the directory where your Python code is.


Forms
~~~~~

You can create forms from your Python code for your content. For that
you are going to need an interface which describes which are the
fields on your object.


.. sourcecode:: python

  from zope import interface, schema

  class IMyContent(interface.Interface):

       email = schema.TextLine(
          title=u"Email address",
          description=u"Your email address, free of spam.",
          required=False)

       contact_url = schema.URI(
          title=u"Contact URL",
          required=True)

.. hint::

  The Python package ``zope.schema`` define a lot of basic type of
  fields. You can get more on the Cheeseshop, but they have to provides
  as well form widgets for web edition.


And your content need to implement this interface. You can implement
these fields with the help of an ``FieldProperty``.

.. sourcecode:: python

  from zope.schema.fieldproperty import FieldProperty

  class MyContent(...):
       ...
       interface.implements(IMyContent)
       email = FieldProperty(IMyContent['email'])
       contact_url = FieldProperty(IMyContent['contact_url'])



So now your object dispose of the ``email`` and ``contact_url``
attributes, like you declared in your interface.


Add forms
`````````

Now, you can define an add form:

.. sourcecode:: python

  from silva.core.conf import forms as silvaforms

  class MyContentAddForm(silvaforms.AddForm):

       silvaconf.context(IMyContent)
       silvaconf.name("My Content")


``silva.name`` have to be the meta type of your content. As you can
see, your interface doesn't provide any fields for the required
``id``, and ``title``, but they are going to be added automatically.

.. hint::

  An add form is a Zope 3 factory, registered for the given Zope 2
  meta type. If you register your own factory, it will be used when
  you create your content via the Silva Management Interface.


If you have a versioned content, you are going to have two interfaces:
one for your content and one for your version. As yours fields should
be versioned, they should be defined on the version's interface:

.. sourcecode:: python

  class IMyVersionContent(interface.Interface):
     """A version of my content object.
     """

     info = schema.Text(title=u"General information")
     ...       # Add others fields


On your add form, you have to explicitly say that form fields are
going to be created using your version's interface *(line 8)*:

.. sourcecode:: python
  :linenos:

  from zope.formlib import form

  class MyContentAddForm(silvaforms.AddForm):

     silvaconf.context(IMyContent)
     silvaconf.name("My Content")

     form_fields = form.FormFields(IMyVersionContent)

After having created the new content, the add form is going to fill
values for these fields on the *editable* object returned by your
content. Since your object is versioned this going to be the version.

Edition forms
`````````````

You can create an edition form:

.. sourcecode:: python

  class MyContentEditForm(silvaforms.EditForm):

       silvaconf.context(IMyContent)


That's it. ``id`` and ``title`` fields are not provided, and should
not: an object can be renamed from its parent container, and the title
is managed via the properties tab.

Like for add forms, when you have an versioned content, you should
create form fields using the version's interface *(line 5)*:

.. sourcecode:: python
  :linenos:

  class MyContentEditForm(silvaforms.EditForm):

       silvaconf.context(IMyContext):

       form_fields = form.FormFields(IMyVersionContent)


Others forms
````````````

You can overrides any form you from the SMI. We define a new interface
with settings fields:

.. sourcecode:: python

  class IMyContentSettings(interface.Interface):
       """Settings for my content.
       """

       hide_email = schema.Bool(
          title=u"Hide email address",
          default=True,
          required=False)
 

And after you can use this interface for your form:

.. sourcecode:: python

  from zope.formlib import form

  class MyContentSettingsForm(silvaforms.PageForm):

       silvaconf.context(IMyContent)
       silvaconf.name("tab_settings")

       # Set form fields using our new interface
       form_fields = form.FormFields(IMyContentSettings) 

       # Define one action
       @silvaforms.action(u"Send information")
       def action_send(self, action, data):
            # data['hide_email'] contain the validated form value 



``silvaconf.name`` is used here to define the name of the form. Here
it will defined as ``tab_settings``, which is accessible via the
``properties`` tab in SMI.

.. hint::

  You can define new actions on adding and edition forms as well, like
  settings custom fields. For more information about that, please
  refer to the formlib documentation.


XML Import
~~~~~~~~~~

You can provide a way to import your content from an XML file. For
this, you are going to write an importer. Here a simple example to
load the simple content of type `MyContent`:

.. sourcecode:: python

  from Products.Silva.silvaxml.xmlimport import SilvaBaseHandler
  from silva.core import conf as silvaconf

  # You need a namespace definition for your XML file
  NS_URI = 'http://mydomain/namespace/mysilvaproject'
  # You tell that's all importers in this Python module are going to use this namespace
  silvaconf.namespace(NS_URI)

  class MyContentHandler(SilvaBaseHandler):

      silvaconf.name('content')            # Name of the tag representing your content.

      def startElementNS(self, name, qname, attrs):
          if name == (NS_URI, 'content'):
              # Get the folder where the element should be, and create the content.
              folder = self.parent()
              content_id = self.generateOrReplaceId(attrs[(None,'id')])
              content_title = attrs[(None, 'title')]
              folder.manage_addProduct['Blog'].manage_addMyContent(content_id, content_title)

              # This is the new current element, them a handler will
              # process sub-tag it will get this element with self.parent()
              self.setResult(getattr(folder, content_id))

      def endElementNS(self, name, qname):
          pass                             # Do nothing here.

This handler will be able to load a content from the following XML
file:

.. sourcecode:: xml

  <?xml version="1.0" encoding="UTF-8" ?>
  <silva xmlns="http://infrae.com/ns/silva"
         xmlns:mysilvaproject="http://mydomain/namespace/mysilvaproject">
     <mysilvaproject:content id="xml_content" title="XML Content" />
  </silva>


Notes
`````

- You can define the namespace only on one class, by setting it at the
  class level like for the name.

- If you don't set a name, your handler will not be registered. That's
  useful when you want to create handler which have only a meaning
  inside one other.

- The base class ``SilvaBaseHandler`` provide some utilities to help
  you to create your content, like the handling of metadata for
  example.

Upgrade step
~~~~~~~~~~~~

An upgrade step can be use to upgrade a content between two versions
of Silva. The upgrade method of the upgrader will be called against
each content of the given content type. Here, a sample to upgrade
`Silva Document` and `Silva Link` objects to Silva `2.1`:

.. sourcecode:: python

  from Products.Silva.upgrade import BaseUpgrader, AnyMetaType

  class MyUpgrade(BaseUpgrader):

      def upgrade(self, obj):
          """You can upgrade your content in this function.
          """
          pass

  myUpgradeForDocument = MyUpgrade(2.1, 'Silva Document') # This register the step for Silva Document
  myUpgradeForLink = MyUpgrade(2.1, 'Silva Link') # This register the step for Silva Link


``AnyMetaType`` can be used to declare that the step would be run
against all the contents, whatever are theirs meta type.

Publishing your extension
-------------------------

If you made an egg, you can release your extension by now:

.. sourcecode:: sh

  $ cd src
  $ cd silva.app.blog
  $ python2.4 setup.py register         # Register your product
  $ python2.4 setup.py bdist_egg upload # Upload a binary version
  $ python2.4 setup.py sdist upload     # Upload sources

This going to register your extension on the `cheeseshop
<http://pypi.python.org/pypi>`_ so other people can you it as well.
